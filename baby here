const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { createClient } = require('@supabase/supabase-js');
const nodemailer = require('nodemailer');
const axios = require('axios');
const QRCode = require('qrcode');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Environment Configuration
const SUPABASE_URL = process.env.REACT_APP_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.REACT_APP_SUPABASE_ANON_KEY;
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const emailConfig = {
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD
  }
};

const ITEXMO_CONFIG = {
  apiKey: process.env.ITEXMO_API_KEY,
  senderId: process.env.ITEXMO_SENDER_ID || 'CLICARE',
  apiUrl: 'https://www.itexmo.com/php_api/api.php'
};

const isSMSConfigured = ITEXMO_CONFIG.apiKey && ITEXMO_CONFIG.apiKey !== 'PR-SAMPL123456_ABCDE';

// Rate Limiting & Security
const failedAttempts = new Map();

const checkAccountRateLimit = (identifier) => {
  const now = Date.now();
  const windowMs = 15 * 60 * 1000;
  const maxAttempts = 5;
  
  if (!failedAttempts.has(identifier)) {
    failedAttempts.set(identifier, []);
  }
  
  const attempts = failedAttempts.get(identifier);
  const recentAttempts = attempts.filter(timestamp => now - timestamp < windowMs);
  failedAttempts.set(identifier, recentAttempts);

  if (recentAttempts.length >= maxAttempts) {
    const oldestAttempt = Math.min(...recentAttempts);
    const timeLeft = windowMs - (now - oldestAttempt);
    const minutesLeft = Math.ceil(timeLeft / 60000);
    
    throw new Error(`Too many failed login attempts for this account. Try again in ${minutesLeft} minutes.`);
  }
};

const recordFailedAttempt = (identifier) => {
  if (!failedAttempts.has(identifier)) {
    failedAttempts.set(identifier, []);
  }
  
  const attempts = failedAttempts.get(identifier);
  attempts.push(Date.now());
  failedAttempts.set(identifier, attempts);
};

const clearFailedAttempts = (identifier) => {
  failedAttempts.delete(identifier);
};

// Utility Functions
const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

const hashPassword = async (password) => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

const verifyPassword = async (password, hashedPassword) => {
  return await bcrypt.compare(password, hashedPassword);
};

const generateTempPatientId = () => {
  const timestamp = Date.now().toString().slice(-6);
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `TEMP${timestamp}${random}`;
};

// Email Service
const sendEmailOTP = async (email, otp, patientName) => {
  try {
    const transporter = nodemailer.createTransporter(emailConfig);
    await transporter.verify();
  
    const mailOptions = {
      from: emailConfig.auth.user,
      to: email,
      subject: 'CLICARE - Your Verification Code',
      html: `
        <div style="font-family: Poppins, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">üè• CliCare Verification Code</h2>
          <p>Hello ${patientName},</p>
          <p>Your verification code is:</p>
          <div style="background: #f3f4f6; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; letter-spacing: 4px; margin: 20px 0;">
            ${otp}
          </div>
          <p><strong>This code will expire in 5 minutes.</strong></p>
          <p>If you didn't request this code, please ignore this email.</p>
          <hr>
          <p><small>CliCare Hospital Management System</small></p>
        </div>
      `
    };

    const result = await transporter.sendMail(mailOptions);
    return result;
  
  } catch (error) {
    throw new Error(`Failed to send email: ${error.message}`);
  }
};

// SMS Service
const sendSMSOTP = async (phoneNumber, otp, patientName) => {
  try {
    if (!isSMSConfigured) {
      throw new Error('SMS service not configured. Please contact administrator.');
    }
  
    let formattedPhone = phoneNumber.toString().trim();
  
    if (formattedPhone.startsWith('+639')) {
      formattedPhone = '0' + formattedPhone.substring(3);
    } else if (formattedPhone.startsWith('639')) {
      formattedPhone = '0' + formattedPhone.substring(2);
    }
  
    if (!/^09\d{9}$/.test(formattedPhone)) {
      throw new Error('Invalid Philippine mobile number format');
    }
  
    const message = `CLICARE: Your verification code is ${otp}. Valid for 5 minutes. Do not share this code.`;
  
    const params = {
      '1': formattedPhone,
      '2': message,
      '3': ITEXMO_CONFIG.apiKey,
      passwd: ITEXMO_CONFIG.apiKey.split('_')[1] || 'default'
    };
  
    const response = await axios.post(ITEXMO_CONFIG.apiUrl, new URLSearchParams(params), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      timeout: 30000
    });
  
    if (response.data && response.data.toString().trim() === '0') {
      return {
        success: true,
        messageId: 'itexmo_' + Date.now(),
        provider: 'iTexMo'
      };
    } else {
      const errorCodes = {
        '1': 'Incomplete parameters',
        '2': 'Invalid number',
        '3': 'Invalid API key',
        '4': 'Maximum SMS per day reached',
        '5': 'Maximum SMS per hour reached',
        '10': 'Duplicate message',
        '15': 'Invalid message',
        '16': 'SMS contains spam words'
      };
    
      const errorCode = response.data.toString().trim();
      const errorMessage = errorCodes[errorCode] || `Unknown error (${errorCode})`;
    
      throw new Error(`SMS sending failed: ${errorMessage}`);
    }
  
  } catch (error) {
    if (error.code === 'ECONNABORTED') {
      throw new Error('SMS service timeout. Please try again.');
    } else if (error.response) {
      throw new Error(`SMS service error: ${error.response.data || error.response.status}`);
    } else if (error.message.includes('Network Error')) {
      throw new Error('Network error. Please check your internet connection.');
    } else {
      throw new Error(error.message || 'Failed to send SMS');
    }
  }
};

// Department Assignment
const assignDepartmentBySymptoms = async (symptoms) => {
  try {
    const { data: symptomData } = await supabase
      .from('symptoms')
      .select('department_id, priority')
      .in('name', symptoms)
      .eq('is_active', true);

    if (symptomData && symptomData.length > 0) {
      const sortedSymptoms = symptomData.sort((a, b) => {
        const priorityOrder = { 'high': 0, 'normal': 1, 'low': 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      });
      
      return sortedSymptoms[0].department_id;
    }
    
    return 2;
  } catch (error) {
    console.error('Error assigning department:', error);
    return 2;
  }
};

// File Upload Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, 'uploads', 'lab-results');
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const originalName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
    cb(null, `${timestamp}_${originalName}`);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);

    if (extname && mimetype) {
      return cb(null, true);
    } else {
      cb(new Error('Only images and documents are allowed!'));
    }
  }
});

const uploadDir = path.join(__dirname, 'uploads', 'lab-results');

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
  console.log('Upload directory created:', uploadDir);
}

// Middleware Configuration
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  }
}));

app.use(cors({
  origin: process.env.NODE_ENV === 'production'
    ? ['https://your-frontend-domain.com']
    : ['http://localhost:3000', 'http://127.0.0.1:3000', 'file://', '*'],
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

const generalLoginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 50,
  message: {
    error: 'Too many requests from this network. Please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 200,
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', generalLimiter);
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

app.use('/uploads', (req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

// Authentication Middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// Healthcare Provider Login
app.post('/api/healthcare/login', generalLoginLimiter, async (req, res) => {
  try {
    const { staffId, password } = req.body;

    if (!staffId || !password) {
      return res.status(400).json({
        error: 'Staff ID and password are required'
      });
    }

    try {
      checkAccountRateLimit(`healthcare:${staffId.toLowerCase()}`);
    } catch (rateLimitError) {
      return res.status(429).json({
        error: rateLimitError.message
      });
    }

    const { data: staffData, error: staffError } = await supabase
      .from('healthStaff')
      .select('*')
      .eq('staff_id', staffId)
      .single();

    if (staffError || !staffData) {
      recordFailedAttempt(`healthcare:${staffId.toLowerCase()}`);
      return res.status(404).json({
        error: 'Healthcare Provider ID not found'
      });
    }

    let isValidPassword = false;
  
    if (staffData.password === password) {
      isValidPassword = true;
    } else {
      try {
        isValidPassword = await verifyPassword(password, staffData.password);
      } catch (error) {
        console.log('Bcrypt comparison failed:', error.message);
      }
    }
  
    if (!isValidPassword) {
      recordFailedAttempt(`healthcare:${staffId.toLowerCase()}`);
      return res.status(401).json({
        error: 'Incorrect password'
      });
    }

    clearFailedAttempts(`healthcare:${staffId.toLowerCase()}`);

    const token = jwt.sign(
      {
        id: staffData.id,
        staff_id: staffData.staff_id,
        name: staffData.name,
        role: staffData.role,
        specialization: staffData.specialization,
        department_id: staffData.department_id,
        type: 'healthcare'
      },
      JWT_SECRET,
      { expiresIn: '8h' }
    );

    const { password: _, ...staffInfo } = staffData;
  
    res.status(200).json({
      success: true,
      token,
      staff: staffInfo,
      message: 'Login successful'
    });

  } catch (error) {
    console.error('Healthcare login error:', error);
    res.status(500).json({
      error: 'Internal server error during login'
    });
  }
});

// Admin Login
app.post('/api/admin/login', generalLoginLimiter, async (req, res) => {
  try {
    const { healthadminid, password } = req.body;

    if (!healthadminid || !password) {
      return res.status(400).json({
        error: 'Admin ID and password are required'
      });
    }

    try {
      checkAccountRateLimit(`admin:${healthadminid.toLowerCase()}`);
    } catch (rateLimitError) {
      return res.status(429).json({
        error: rateLimitError.message
      });
    }

    const { data: adminData, error: adminError } = await supabase
      .from('healthAdmin')
      .select('*')
      .eq('healthadmin_id', healthadminid)
      .single();

    if (adminError || !adminData) {
      recordFailedAttempt(`admin:${healthadminid.toLowerCase()}`);
      return res.status(401).json({
        error: 'Invalid credentials'
      });
    }

    let isValidPassword = false;
  
    if (adminData.password === password) {
      isValidPassword = true;
    } else {
      try {
        isValidPassword = await verifyPassword(password, adminData.password);
      } catch (error) {
        console.log('Bcrypt comparison failed:', error.message);
      }
    }
  
    if (!isValidPassword) {
      recordFailedAttempt(`admin:${healthadminid.toLowerCase()}`);
      return res.status(401).json({
        error: 'Invalid credentials'
      });
    }

    clearFailedAttempts(`admin:${healthadminid.toLowerCase()}`);

    const token = jwt.sign(
      {
        id: adminData.id,
        healthadmin_id: adminData.healthadmin_id,
        name: adminData.name,
        position: adminData.position,
        type: 'admin'
      },
      JWT_SECRET,
      { expiresIn: '8h' }
    );

    const { password: _, ...adminInfo } = adminData;
  
    res.status(200).json({
      success: true,
      token,
      admin: adminInfo,
      message: 'Login successful'
    });

  } catch (error) {
    console.error('Admin login error:', error);
    res.status(500).json({
      error: 'Internal server error during login'
    });
  }
});

// Send OTP
app.post('/api/outpatient/send-otp', generalLoginLimiter, async (req, res) => {
  try {
    const { patientId, contactInfo, contactType } = req.body;

    if (!patientId || !contactInfo || !contactType) {
      return res.status(400).json({
        error: 'Patient ID, contact information, and contact type are required'
      });
    }

    if (!['email', 'phone'].includes(contactType)) {
      return res.status(400).json({
        error: 'Contact type must be email or phone'
      });
    }

    if (contactType === 'phone' && !isSMSConfigured) {
      return res.status(400).json({
        error: 'SMS verification is not configured. Please use email verification or contact support.'
      });
    }

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select('*')
      .eq('patient_id', patientId.toUpperCase())
      .single();

    if (patientError || !patientData) {
      return res.status(404).json({
        error: 'Patient ID not found. Please check your Patient ID.'
      });
    }

    const dbContactInfo = contactType === 'email'
      ? patientData.email
      : patientData.contact_no;
    
    if (dbContactInfo !== contactInfo) {
      return res.status(400).json({
        error: `The ${contactType} doesn't match our records for this Patient ID`
      });
    }

    await supabase
      .from('otpVerification')
      .delete()
      .eq('patient_id', patientId.toUpperCase())
      .eq('contact_info', contactInfo);

    const otp = generateOTP();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
    const { data: otpRecord, error: otpError } = await supabase
      .from('otpVerification')
      .insert({
        patient_id: patientId.toUpperCase(),
        contact_info: contactInfo,
        contact_type: contactType,
        otp_code: otp,
        expires_at: expiresAt.toISOString()
      })
      .select()
      .single();

    if (otpError) {
      return res.status(500).json({
        error: 'Failed to generate verification code'
      });
    }

    try {
      if (contactType === 'email') {
        await sendEmailOTP(contactInfo, otp, patientData.name);
        res.status(200).json({
          success: true,
          message: 'Verification code sent to your email',
          expiresIn: 300
        });
      } else if (contactType === 'phone') {
        await sendSMSOTP(contactInfo, otp, patientData.name);
        res.status(200).json({
          success: true,
          message: 'Verification code sent to your phone',
          expiresIn: 300,
          provider: 'iTexMo'
        });
      }
    } catch (sendError) {
      await supabase
        .from('otpVerification')
        .delete()
        .eq('id', otpRecord.id);

      return res.status(500).json({
        error: `Failed to send verification code via ${contactType}. Please try again.`,
        details: sendError.message
      });
    }

  } catch (error) {
    console.error('Send OTP error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Verify OTP
app.post('/api/outpatient/verify-otp', generalLoginLimiter, async (req, res) => {
  try {
    const { patientId, contactInfo, otp, deviceType } = req.body;

    if (!patientId || !contactInfo || !otp) {
      return res.status(400).json({
        error: 'Patient ID, contact info, and OTP are required'
      });
    }

    const { data: otpData, error: otpError } = await supabase
      .from('otpVerification')
      .select('*')
      .eq('patient_id', patientId.toUpperCase())
      .eq('contact_info', contactInfo)
      .eq('is_verified', false)
      .gte('expires_at', new Date().toISOString())
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (otpError || !otpData) {
      return res.status(400).json({
        error: 'Invalid or expired verification code'
      });
    }

    if (otpData.otp_code !== otp) {
      await supabase
        .from('otpVerification')
        .update({ attempts: otpData.attempts + 1 })
        .eq('id', otpData.id);

      return res.status(400).json({
        error: 'Invalid verification code'
      });
    }

    await supabase
      .from('otpVerification')
      .update({ is_verified: true })
      .eq('id', otpData.id);

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select('*')
      .eq('patient_id', patientId.toUpperCase())
      .single();

    if (patientError || !patientData) {
      return res.status(404).json({
        error: 'Patient data not found'
      });
    }

    const { data: emergencyContactData, error: emergencyError } = await supabase
      .from('emergencyContact')
      .select('*')
      .eq('patient_id', patientData.id)
      .single();

    if (emergencyError) {
      console.log('No emergency contact found for patient:', patientData.patient_id);
    }

    const token = jwt.sign(
      {
        patientId: patientData.patient_id,
        type: 'outpatient',
        loginMethod: otpData.contact_type,
        deviceType: deviceType || 'unknown'
      },
      JWT_SECRET,
      { expiresIn: '8h' }
    );

    res.status(200).json({
      success: true,
      message: 'Login successful',
      token: token,
      patient: {
        patient_id: patientData.patient_id,
        name: patientData.name,
        email: patientData.email,
        contact_no: patientData.contact_no,
        birthday: patientData.birthday,
        age: patientData.age,
        sex: patientData.sex,
        address: patientData.address,
        registration_date: patientData.registration_date,
        emergency_contact_name: emergencyContactData?.name || '',
        emergency_contact_relationship: emergencyContactData?.relationship || '',
        emergency_contact_no: emergencyContactData?.contact_number || ''
      }
    });

  } catch (error) {
    console.error('Verify OTP error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Symptoms
app.get('/api/symptoms', async (req, res) => {
  try {
    const { data: symptomsData, error } = await supabase
      .from('symptoms')
      .select('*')
      .eq('is_active', true)
      .order('category')
      .order('name');

    if (error) {
      console.error('Symptoms fetch error:', error);
      return res.status(500).json({ error: 'Failed to fetch symptoms' });
    }

    console.log('Raw symptoms data:', symptomsData);

    if (!symptomsData || symptomsData.length === 0) {
      console.log('No symptoms found in database');
      return res.status(200).json({
        success: true,
        symptoms: []
      });
    }

    const groupedSymptoms = symptomsData.reduce((acc, symptom) => {
      if (!acc[symptom.category]) {
        acc[symptom.category] = [];
      }
      acc[symptom.category].push(symptom.name);
      return acc;
    }, {});

    const formattedSymptoms = Object.entries(groupedSymptoms).map(([category, symptoms]) => ({
      category,
      symptoms: symptoms
    }));

    console.log('Formatted symptoms:', formattedSymptoms);

    res.status(200).json({
      success: true,
      symptoms: formattedSymptoms
    });

  } catch (error) {
    console.error('Get symptoms error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Departments
app.get('/api/departments', async (req, res) => {
  try {
    const { data: departmentsData, error } = await supabase
      .from('department')
      .select('*')
      .eq('status', 'active')
      .order('name');

    if (error) {
      return res.status(500).json({ error: 'Failed to fetch departments' });
    }

    res.status(200).json({
      success: true,
      departments: departmentsData
    });

  } catch (error) {
    console.error('Get departments error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Patient Registration
app.post('/api/patient/register', async (req, res) => {
  try {
    console.log('Registration request received:', req.body);
    
    const {
      name,
      birthday,
      age,
      sex,
      address,
      contact_no,
      email,
      emergency_contact_name,
      emergency_contact_relationship,
      emergency_contact_no,
      symptoms
    } = req.body;

    if (!name || !birthday || !age || !sex || !address || !contact_no || !email) {
      console.log('Missing required fields');
      return res.status(400).json({ 
        error: 'Missing required fields' 
      });
    }

    const patientId = `PAT${Date.now().toString().slice(-6)}${Math.floor(Math.random() * 1000).toString().padStart(3, '0')}`;
    console.log('Generated Patient ID:', patientId);

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .insert({
        patient_id: patientId,
        name,
        birthday,
        age: parseInt(age),
        sex,
        address,
        contact_no,
        email: email.toLowerCase(),
        registration_date: new Date().toISOString().split('T')[0]
      })
      .select()
      .single();

    if (patientError) {
      console.error('Patient registration error:', patientError);
      return res.status(500).json({ 
        error: 'Patient registration failed',
        details: patientError.message 
      });
    }

    console.log('Patient created:', patientData);

    if (emergency_contact_name || emergency_contact_relationship || emergency_contact_no) {
      const { error: emergencyError } = await supabase
        .from('emergencyContact')
        .insert({
          patient_id: patientData.id,
          name: emergency_contact_name || '',
          contact_number: emergency_contact_no || '',
          relationship: emergency_contact_relationship || ''
        });

      if (emergencyError) {
        console.error('Emergency contact error:', emergencyError);
      }
    }

    if (symptoms && symptoms.length > 0) {
      try {
        let assignedDepartmentId = 2;
        if (parseInt(age) < 18) {
          assignedDepartmentId = 4;
        }

        const { data: visitData, error: visitError } = await supabase
          .from('visit')
          .insert({
            patient_id: patientData.id,
            visit_date: new Date().toISOString().split('T')[0],
            visit_time: new Date().toTimeString().split(' ')[0],
            appointment_type: 'Walk-in Registration',
            symptoms: Array.isArray(symptoms) ? symptoms.join(', ') : symptoms
          })
          .select()
          .single();

        if (!visitError && visitData) {
          const { data: existingQueue } = await supabase
            .from('queue')
            .select('queue_no')
            .eq('department_id', assignedDepartmentId)
            .order('queue_no', { ascending: false })
            .limit(1);

          const nextQueueNo = existingQueue && existingQueue.length > 0 ? existingQueue[0].queue_no + 1 : 1;

          const { error: queueError } = await supabase
            .from('queue')
            .insert({
              visit_id: visitData.visit_id,
              department_id: assignedDepartmentId,
              queue_no: nextQueueNo,
              status: 'waiting'
            });

          if (queueError) {
            console.error('Queue insertion error:', queueError);
          } else {
            console.log(`Patient queued in department ${assignedDepartmentId}, position ${nextQueueNo}`);
          }
        }
      } catch (visitError) {
        console.error('Visit creation error:', visitError);
}
    }

    console.log('Registration completed for:', patientData.name);

    res.status(201).json({
      success: true,
      patient: patientData,
      message: 'Patient registered successfully'
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ 
      error: 'Internal server error during registration',
      details: error.message 
    });
  }
});

// Temporary Registration
app.post('/api/temp-registration', async (req, res) => {
  try {
    console.log('Temp registration request:', req.body);
    
    const {
      name,
      birthday,
      age,
      sex,
      address,
      contact_no,
      email,
      emergency_contact_name,
      emergency_contact_relationship,
      emergency_contact_no,
      preferred_time,
      created_date,
      status,
      expires_at
    } = req.body;

    const temp_patient_id = generateTempPatientId();

    const { data: tempRegData, error: tempRegError } = await supabase
      .from('tempReg')
      .insert({
        name,
        birthday,
        age: parseInt(age),
        sex,
        address,
        contact_no,
        email: email.toLowerCase(),
        emergency_contact_name,
        emergency_contact_relationship,
        emergency_contact_no,
        preferred_time,
        created_date,
        status: status || 'pending',
        expires_at,
        temp_patient_id
      })
      .select()
      .single();

    if (tempRegError) {
      console.error('Temp registration error:', tempRegError);
      
      if (tempRegError.code === '23505') {
        return res.status(400).json({
          error: 'Email or contact number already registered. Please use different details.'
        });
      }
      
      return res.status(500).json({
        error: 'Registration failed. Please try again.',
        details: tempRegError.message
      });
    }

    console.log('Temp registration created:', tempRegData.name, 'ID:', tempRegData.temp_patient_id);

    res.status(201).json({
      success: true,
      message: 'Temporary registration created successfully',
      temp_id: tempRegData.temp_id,
      temp_patient_id: tempRegData.temp_patient_id
    });

  } catch (error) {
    console.error('Temp registration error:', error);
    res.status(500).json({
      error: 'Registration failed. Please try again.',
      details: error.message
    });
  }
});

// Temporary Registration Health Assessment
app.put('/api/temp-registration/:id/health-assessment', async (req, res) => {
  try {
    console.log('Health assessment update for ID:', req.params.id);
    
    const { id } = req.params;
    const {
      symptoms,
      duration,
      severity,
      previous_treatment,
      allergies,
      medications,
      preferred_date,
      preferred_time_slot,
      scheduled_date,
      status
    } = req.body;

    const { data: updatedData, error: updateError } = await supabase
      .from('tempReg')
      .update({
        symptoms,
        duration,
        severity,
        previous_treatment,
        allergies,
        medications,
        preferred_date,
        preferred_time_slot,
        scheduled_date,
        status: status || 'completed',
        updated_at: new Date().toISOString()
      })
      .eq('temp_id', id)
      .select()
      .single();

    if (updateError) {
      console.error('Health assessment update error:', updateError);
      return res.status(500).json({
        error: 'Failed to update health assessment. Please try again.',
        details: updateError.message
      });
    }

    if (!updatedData) {
      return res.status(404).json({
        error: 'Registration not found'
      });
    }

    console.log('Health assessment updated for:', updatedData.name);

    res.json({
      success: true,
      message: 'Health assessment updated successfully',
      data: updatedData
    });

  } catch (error) {
    console.error('Health assessment update error:', error);
    res.status(500).json({
      error: 'Failed to update health assessment. Please try again.',
      details: error.message
    });
  }
});

// Get Temporary Registration
app.get('/api/temp-registration/:tempPatientId', async (req, res) => {
  try {
    const { tempPatientId } = req.params;
    
    const { data: regData, error: regError } = await supabase
      .from('tempReg')
      .select('temp_id, temp_patient_id, name, email, symptoms, duration, severity, preferred_date, preferred_time_slot, scheduled_date, status, qr_code')
      .eq('temp_patient_id', tempPatientId)
      .single();
    
    if (regError || !regData) {
      return res.status(404).json({
        error: 'Registration not found'
      });
    }
    
    res.json({
      success: true,
      data: regData
    });
    
  } catch (error) {
    console.error('Get registration error:', error);
    res.status(500).json({
      error: 'Failed to retrieve registration details',
      details: error.message
    });
  }
});

// Create Visit
app.post('/api/patient/visit', async (req, res) => {
  try {
    console.log('Visit booking request:', req.body);
    
    const {
      patient_id,
      symptoms,
      duration,
      severity,
      previous_treatment,
      allergies,
      medications,
      appointment_type
    } = req.body;

    if (!patient_id || !symptoms) {
      return res.status(400).json({ 
        error: 'Patient ID and symptoms are required' 
      });
    }

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select('id, patient_id, name')
      .eq('patient_id', patient_id)
      .single();

    if (patientError || !patientData) {
      console.log('Patient not found:', patient_id);
      return res.status(404).json({ 
        error: 'Patient not found' 
      });
    }

    const { data: visitData, error: visitError } = await supabase
      .from('visit')
      .insert({
        patient_id: patientData.id,
        visit_date: new Date().toISOString().split('T')[0],
        visit_time: new Date().toTimeString().split(' ')[0],
        appointment_type: appointment_type || 'Walk-in',
        symptoms: symptoms
      })
      .select()
      .single();

    if (visitError) {
      console.error('Visit creation error:', visitError);
      return res.status(500).json({ 
        error: 'Failed to create visit record',
        details: visitError.message 
      });
    }

    const queueNumber = Math.floor(Math.random() * 100) + 1;
    
    const { data: queueData, error: queueError } = await supabase
      .from('queue')
      .insert({
        visit_id: visitData.visit_id,
        department_id: 2,
        queue_no: queueNumber,
        status: 'waiting'
      })
      .select()
      .single();

    console.log('Visit created for:', patientData.name);

    res.status(201).json({
      success: true,
      visit: visitData,
      queue_number: queueData?.queue_no || queueNumber,
      department: 'Internal Medicine',
      estimated_wait: '15-30 minutes',
      message: 'Appointment booked successfully'
    });

  } catch (error) {
    console.error('Visit booking error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      details: error.message 
    });
  }
});

// Healthcare Provider Profile
app.get('/api/healthcare/profile', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: staffData, error } = await supabase
      .from('healthStaff')
      .select('id, staff_id, name, role, specialization, department_id, license_no, contact_no')
      .eq('id', req.user.id)
      .single();

    if (error || !staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    res.json(staffData);
  } catch (error) {
    console.error('Get healthcare profile error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Admin Profile
app.get('/api/admin/profile', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: adminData, error } = await supabase
      .from('healthAdmin')
      .select('id, healthadmin_id, name, position')
      .eq('id', req.user.id)
      .single();

    if (error || !adminData) {
      return res.status(404).json({
        error: 'Admin not found'
      });
    }

    res.status(200).json({
      success: true,
      admin: adminData
    });

  } catch (error) {
    console.error('Get admin profile error:', error);
    res.status(500).json({
      error: 'Internal server error'
    });
  }
});

// Get Patient Profile
app.get('/api/patient/profile', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'outpatient') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select(`
        *,
        emergencyContact(
          name,
          contact_number,
          relationship
        )
      `)
      .eq('patient_id', req.user.patientId)
      .single();

    if (patientError || !patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    res.status(200).json({
      success: true,
      patient: patientData
    });

  } catch (error) {
    console.error('Patient profile error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get All Patients (Consulted by Department)
app.get('/api/healthcare/all-patients', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: staffData } = await supabase
      .from('healthStaff')
      .select('department_id, specialization')
      .eq('id', req.user.id)
      .single();

    if (!staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    const { data: patientsData, error: patientsError } = await supabase
      .from('queue')
      .select(`
        visit!inner(
          patient_id,
          outPatient!inner(
            id,
            patient_id,
            name,
            birthday,
            age,
            sex,
            address,
            contact_no,
            email,
            registration_date
          )
        )
      `)
      .eq('department_id', staffData.department_id)
      .order('created_time', { ascending: false });

    if (patientsError) {
      console.error('All patients fetch error:', patientsError);
      return res.status(500).json({ error: 'Failed to fetch patients' });
    }

    const uniquePatients = [];
    const seenPatientIds = new Set();

    patientsData.forEach(item => {
      const patient = item.visit.outPatient;
      if (!seenPatientIds.has(patient.patient_id)) {
        seenPatientIds.add(patient.patient_id);
        uniquePatients.push({
          id: patient.id,
          patient_id: patient.patient_id,
          name: patient.name,
          birthday: patient.birthday,
          age: patient.age,
          sex: patient.sex,
          address: patient.address,
          contact_no: patient.contact_no,
          email: patient.email,
          registration_date: patient.registration_date
        });
      }
    });

    res.status(200).json({
      success: true,
      patients: uniquePatients,
      totalCount: uniquePatients.length,
      department: {
        id: staffData.department_id,
        specialization: staffData.specialization
      }
    });

  } catch (error) {
    console.error('All patients error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Patient Details
app.get('/api/healthcare/patient-details/:patientId', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patientId } = req.params;
    const { data: staffData } = await supabase
      .from('healthStaff')
      .select('department_id')
      .eq('id', req.user.id)
      .single();

    if (!staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    const { data: visitCheck } = await supabase
      .from('queue')
      .select(`
        visit!inner(
          outPatient!inner(patient_id)
        )
      `)
      .eq('department_id', staffData.department_id)
      .eq('visit.outPatient.patient_id', patientId)
      .limit(1);

    if (!visitCheck || visitCheck.length === 0) {
      return res.status(403).json({ error: 'Patient has not visited your department' });
    }

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select(`
        *,
        emergencyContact(
          name,
          contact_number,
          relationship
        )
      `)
      .eq('patient_id', patientId)
      .single();

    if (patientError || !patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    res.status(200).json({
      success: true,
      patient: patientData
    });

  } catch (error) {
    console.error('Patient details error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get My Patients
app.get('/api/healthcare/my-patients', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { date } = req.query;
    const today = new Date().toISOString().split('T')[0];
    const filterDate = date || today;

    const { data: staffData } = await supabase
      .from('healthStaff')
      .select('department_id, specialization')
      .eq('id', req.user.id)
      .single();

    if (!staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    const { data: patientsData, error: patientsError } = await supabase
      .from('diagnosis')
      .select(`
        healthstaff_id,
        visit!inner(
          visit_id,
          visit_date,
          visit_time,
          symptoms,
          appointment_type,
          outPatient!inner(
            id,
            patient_id,
            name,
            age,
            sex,
            contact_no,
            email
          ),
          queue!inner(
            status,
            department_id
          )
        )
      `)
      .eq('healthstaff_id', req.user.id)
      .eq('visit.visit_date', filterDate)
      .eq('visit.queue.department_id', staffData.department_id)
      .eq('visit.queue.status', 'completed')
      .order('created_at', { ascending: false });

    if (patientsError) {
      console.error('Patients fetch error:', patientsError);
      return res.status(500).json({ error: 'Failed to fetch patients' });
    }

    const uniquePatients = [];
    const seenPatientIds = new Set();

    patientsData.forEach(item => {
      const patientId = item.visit.outPatient.patient_id;
      if (!seenPatientIds.has(patientId)) {
        seenPatientIds.add(patientId);
        uniquePatients.push({
          patient_id: patientId,
          name: item.visit.outPatient.name,
          age: item.visit.outPatient.age,
          sex: item.visit.outPatient.sex,
          contact_no: item.visit.outPatient.contact_no,
          email: item.visit.outPatient.email,
          lastVisit: item.visit.visit_date,
          lastSymptoms: item.visit.symptoms,
          queueStatus: 'completed'
        });
      }
    });

    res.status(200).json({
      success: true,
      patients: uniquePatients,
      department: {
        id: staffData.department_id,
        specialization: staffData.specialization
      }
    });

  } catch (error) {
    console.error('My patients error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get My Patients Queue
app.get('/api/healthcare/my-patients-queue', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { date } = req.query;
    const today = new Date().toISOString().split('T')[0];
    const filterDate = date || today;

    const { data: staffData } = await supabase
      .from('healthStaff')
      .select('department_id, specialization')
      .eq('id', req.user.id)
      .single();

    if (!staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    const { data: queuePatients, error: queueError } = await supabase
      .from('queue')
      .select(`
        queue_id,
        queue_no,
        status,
        created_time,
        visit!inner(
          visit_id,
          visit_date,
          visit_time,
          symptoms,
          appointment_type,
          outPatient!inner(
            id,
            patient_id,
            name,
            age,
            sex,
            contact_no,
            email
          )
        )
      `)
      .eq('department_id', staffData.department_id)
      .in('status', ['waiting', 'in_progress'])
      .eq('visit.visit_date', filterDate)
      .order('queue_no', { ascending: true });

    const { data: completedPatients, error: completedError } = await supabase
      .from('diagnosis')
      .select(`
        created_at,
        visit!inner(
          visit_id,
          visit_date,
          visit_time,
          symptoms,
          appointment_type,
          outPatient!inner(
            id,
            patient_id,
            name,
            age,
            sex,
            contact_no,
            email
          ),
          queue!inner(
            status,
            queue_no,
            department_id
          )
        )
      `)
      .eq('healthstaff_id', req.user.id)
      .eq('visit.visit_date', filterDate)
      .eq('visit.queue.department_id', staffData.department_id)
      .eq('visit.queue.status', 'completed')
      .order('created_at', { ascending: false });

    let allPatients = [];

    if (queuePatients && !queueError) {
      queuePatients.forEach(item => {
        allPatients.push({
          patient_id: item.visit.outPatient.patient_id,
          name: item.visit.outPatient.name,
          age: item.visit.outPatient.age,
          sex: item.visit.outPatient.sex,
          contact_no: item.visit.outPatient.contact_no,
          email: item.visit.outPatient.email,
          lastVisit: item.visit.visit_date,
          lastSymptoms: item.visit.symptoms,
          queueStatus: item.status,
          queueNumber: item.queue_no,
          visitTime: item.visit.visit_time,
          isInQueue: true
        });
      });
    }

    if (completedPatients && !completedError) {
      completedPatients.forEach(item => {
        const patientId = item.visit.outPatient.patient_id;

        if (!allPatients.find(p => p.patient_id === patientId)) {
          allPatients.push({
            patient_id: patientId,
            name: item.visit.outPatient.name,
            age: item.visit.outPatient.age,
            sex: item.visit.outPatient.sex,
            contact_no: item.visit.outPatient.contact_no,
            email: item.visit.outPatient.email,
            lastVisit: item.visit.visit_date,
            lastSymptoms: item.visit.symptoms,
            queueStatus: 'completed',
            queueNumber: item.visit.queue[0]?.queue_no,
            visitTime: item.visit.visit_time,
            isInQueue: false
          });
        }
      });
    }

    res.status(200).json({
      success: true,
      patients: allPatients,
      department: {
        id: staffData.department_id,
        specialization: staffData.specialization
      }
    });

  } catch (error) {
    console.error('My patients queue error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Patient History
app.get('/api/healthcare/patient-history/:patientId', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patientId } = req.params;
    const { page = 1, limit = 10 } = req.query;
    const offset = (page - 1) * limit;

    const { data: patientData, error: patientError } = await supabase
      .from('outPatient')
      .select(`
        id,
        patient_id,
        name,
        birthday,
        age,
        sex,
        address,
        contact_no,
        email,
        registration_date,
        emergencyContact(
          name,
          contact_number,
          relationship
        )
      `)
      .eq('patient_id', patientId)
      .single();

    if (patientError || !patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: visitHistory, error: visitError } = await supabase
      .from('visit')
      .select(`
        visit_id,
        visit_date,
        visit_time,
        appointment_type,
        symptoms,
        diagnosis(
          diagnosis_id,
          diagnosis_description,
          diagnosis_type,
          severity,
          notes,
          healthStaff(
            name,
            specialization
          )
        ),
        queue(
          queue_no,
          status,
          department(
            name
          )
        )
      `)
      .eq('patient_id', patientData.id)
      .order('visit_date', { ascending: false })
      .order('visit_time', { ascending: false })
      .range(offset, offset + limit - 1);

    if (visitError) {
      console.error('Visit history error:', visitError);
      return res.status(500).json({ error: 'Failed to fetch visit history' });
    }

    const { count: totalVisits } = await supabase
      .from('visit')
      .select('*', { count: 'exact', head: true })
      .eq('patient_id', patientData.id);

    res.status(200).json({
      success: true,
      patient: patientData,
      visitHistory: visitHistory || [],
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalVisits / limit),
        totalVisits: totalVisits || 0,
        hasNextPage: (page * limit) < totalVisits
      }
    });

  } catch (error) {
    console.error('Patient history error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Patient Queue
app.get('/api/healthcare/patient-queue', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: staffData } = await supabase
      .from('healthStaff')
      .select('department_id, specialization')
      .eq('id', req.user.id)
      .single();

    if (!staffData) {
      return res.status(404).json({ error: 'Staff not found' });
    }

    const { data: queueData, error: queueError } = await supabase
      .from('queue')
      .select(`
        queue_id,
        queue_no,
        status,
        created_time,
        visit!inner(
          visit_id,
          symptoms,
          visit_date,
          visit_time,
          appointment_type,
          outPatient!inner(
            patient_id,
            name,
            age,
            sex,
            contact_no
          )
        ),
        department!inner(
          name
        )
      `)
      .eq('department_id', staffData.department_id)
      .in('status', ['waiting', 'in_progress'])
      .order('queue_no', { ascending: true });

    if (queueError) {
      console.error('Queue fetch error:', queueError);
      return res.status(500).json({ error: 'Failed to fetch queue' });
    }

    const today = new Date().toISOString().split('T')[0];
    
    const { data: todayVisits } = await supabase
      .from('visit')
      .select('visit_id, outPatient!inner(patient_id)')
      .eq('visit_date', today);

    const { data: labResults } = await supabase
      .from('labResult')
      .select('result_id')
      .eq('upload_date', today);

    res.status(200).json({
      success: true,
      queue: queueData || [],
      todayStats: {
        myPatients: todayVisits?.length || 0,
        labResults: labResults?.length || 0
      },
      department: {
        id: staffData.department_id,
        specialization: staffData.specialization
      }
    });

  } catch (error) {
    console.error('Patient queue error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update Queue Status
app.patch('/api/healthcare/queue/:queueId/status', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { queueId } = req.params;
    const { status, diagnosis_description, diagnosis_code, severity, notes } = req.body;

    if (!['waiting', 'in_progress', 'completed'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }

    const { data: queueData, error: queueFetchError } = await supabase
      .from('queue')
      .select(`
        *,
        visit!inner(
          visit_id,
          patient_id,
          outPatient!inner(id, patient_id)
        )
      `)
      .eq('queue_id', queueId)
      .single();

    if (queueFetchError || !queueData) {
      return res.status(404).json({ error: 'Queue entry not found' });
    }

    const { data: updatedQueue, error: updateError } = await supabase
      .from('queue')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('queue_id', queueId)
      .select()
      .single();

    if (updateError) {
      return res.status(500).json({ error: 'Failed to update queue status' });
    }

    let diagnosisData = null;
    let medicalRecordData = null;

    if (status === 'completed' && diagnosis_description) {
      const { data: newDiagnosis, error: diagnosisError } = await supabase
        .from('diagnosis')
        .insert({
          visit_id: queueData.visit.visit_id,
          patient_id: queueData.visit.outPatient.id,
          healthstaff_id: req.user.id,
          diagnosis_code: diagnosis_code || 'Z00.00',
          diagnosis_description,
          diagnosis_type: 'primary',
          severity: severity || 'moderate',
          notes: notes || ''
        })
        .select()
        .single();

      if (!diagnosisError) {
        diagnosisData = newDiagnosis;

        const { data: newMedicalRecord, error: medicalRecordError } = await supabase
          .from('medicalRecord')
          .insert({
            patient_id: queueData.visit.outPatient.id,
            visit_id: queueData.visit.visit_id,
            result_id: null
          })
          .select()
          .single();

        if (!medicalRecordError) {
          medicalRecordData = newMedicalRecord;
        } else {
          console.warn('Medical record creation failed:', medicalRecordError);
        }
      } else {
        console.warn('Diagnosis creation failed:', diagnosisError);
}
    }

    res.status(200).json({
      success: true,
      queue: updatedQueue,
      diagnosis: diagnosisData,
      medicalRecord: medicalRecordData,
      message: 'Queue status updated successfully'
    });

  } catch (error) {
    console.error('Update queue status error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create Diagnosis
app.post('/api/healthcare/diagnosis', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { 
      visit_id, 
      patient_id, 
      diagnosis_code, 
      diagnosis_description, 
      diagnosis_type, 
      severity, 
      notes,
      result_id 
    } = req.body;

    if (!visit_id || !patient_id || !diagnosis_description) {
      return res.status(400).json({ error: 'Visit ID, patient ID, and diagnosis description are required' });
    }

    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id')
      .eq('patient_id', patient_id)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: diagnosisData, error: diagnosisError } = await supabase
      .from('diagnosis')
      .insert({
        visit_id: parseInt(visit_id),
        patient_id: patientData.id,
        healthstaff_id: req.user.id,
        diagnosis_code,
        diagnosis_description,
        diagnosis_type: diagnosis_type || 'primary',
        severity: severity || 'moderate',
        notes
      })
      .select()
      .single();

    if (diagnosisError) {
      console.error('Diagnosis creation error:', diagnosisError);
      return res.status(500).json({ error: 'Failed to create diagnosis' });
    }

    const { data: medicalRecordData, error: medicalRecordError } = await supabase
      .from('medicalRecord')
      .insert({
        patient_id: patientData.id,
        visit_id: parseInt(visit_id),
        result_id: result_id ? parseInt(result_id) : null
      })
      .select()
      .single();

    if (medicalRecordError) {
      console.error('Medical record creation error:', medicalRecordError);
      console.warn('Medical record not created, but diagnosis was successful');
    }

    res.status(201).json({
      success: true,
      diagnosis: diagnosisData,
      medicalRecord: medicalRecordData,
      message: 'Diagnosis and medical record created successfully'
    });

  } catch (error) {
    console.error('Create diagnosis error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Medical Records
app.get('/api/healthcare/medical-records/:patientId', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patientId } = req.params;
    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id, patient_id, name')
      .eq('patient_id', patientId)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: medicalRecords, error: medicalRecordsError } = await supabase
      .from('medicalRecord')
      .select(`
        *,
        visit!inner(
          visit_id,
          visit_date,
          visit_time,
          appointment_type,
          symptoms
        ),
        labResult(
          result_id,
          file_path,
          upload_date,
          results,
          interpretation
        )
      `)
      .eq('patient_id', patientData.id)
      .order('created_at', { ascending: false });

    if (medicalRecordsError) {
      console.error('Medical records fetch error:', medicalRecordsError);
      return res.status(500).json({ error: 'Failed to fetch medical records' });
    }

    res.status(200).json({
      success: true,
      patient: {
        id: patientData.id,
        patient_id: patientData.patient_id,
        name: patientData.name
      },
      medicalRecords: medicalRecords || []
    });

  } catch (error) {
    console.error('Get medical records error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create Lab Request (Healthcare Provider)
app.post('/api/healthcare/lab-requests', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patient_id, test_name, test_type, priority, instructions, due_date } = req.body;

    if (!patient_id || !test_name || !test_type) {
      return res.status(400).json({ error: 'Patient ID, test name, and test type are required' });
    }

    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id, patient_id, name')
      .eq('patient_id', patient_id)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const today = new Date().toISOString().split('T')[0];
    let { data: visitData } = await supabase
      .from('visit')
      .select('visit_id')
      .eq('patient_id', patientData.id)
      .eq('visit_date', today)
      .single();

    if (!visitData) {
      const { data: newVisit, error: visitError } = await supabase
        .from('visit')
        .insert({
          patient_id: patientData.id,
          visit_date: today,
          visit_time: new Date().toTimeString().split(' ')[0],
          appointment_type: 'Lab Request',
          symptoms: 'Lab test requested'
        })
        .select()
        .single();

      if (visitError) {
        return res.status(500).json({ error: 'Failed to create visit record' });
      }
      visitData = newVisit;
    }

    const { data: labRequestData, error: labRequestError } = await supabase
      .from('labRequest')
      .insert({
        visit_id: visitData.visit_id,
        staff_id: req.user.id,
        test_type: test_type,
        due_date: due_date,
        status: 'pending'
      })
      .select()
      .single();

    if (labRequestError) {
      console.error('Lab request creation error:', labRequestError);
      return res.status(500).json({ error: 'Failed to create lab request' });
    }

    res.status(201).json({
      success: true,
      labRequest: labRequestData,
      message: 'Lab request created successfully'
    });

  } catch (error) {
    console.error('Create lab request error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Lab Requests (Healthcare Provider)
app.get('/api/healthcare/lab-requests', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: labRequests, error: labRequestsError } = await supabase
      .from('labRequest')
      .select(`
        *,
        visit!inner(
          visit_id,
          visit_date,
          outPatient!inner(
            patient_id,
            name,
            age,
            sex,
            contact_no
          )
        ),
        labResult(
          result_id,
          file_path,
          upload_date,
          results
        )
      `)
      .eq('staff_id', req.user.id) 
      .order('request_id', { ascending: false });

    if (labRequestsError) {
      console.error('Lab requests fetch error:', labRequestsError);
      return res.status(500).json({ error: 'Failed to fetch lab requests' });
    }

    const formattedRequests = labRequests.map(request => ({
      request_id: request.request_id,
      test_name: request.test_type,
      test_type: request.test_type,
      priority: 'normal',
      status: request.status,
      instructions: '',
      due_date: request.due_date,
      created_at: request.visit.visit_date,
      patient: {
        patient_id: request.visit.outPatient.patient_id,
        name: request.visit.outPatient.name,
        age: request.visit.outPatient.age,
        sex: request.visit.outPatient.sex,
        contact_no: request.visit.outPatient.contact_no
      },
      labResult: request.labResult?.[0] ? {
        result_id: request.labResult[0].result_id,
        file_name: request.labResult[0].file_path ? request.labResult[0].file_path.split('/').pop() : null,
        file_url: request.labResult[0].file_path,
        upload_date: request.labResult[0].upload_date,
        results: request.labResult[0].results
      } : null
    }));

    res.status(200).json({
      success: true,
      labRequests: formattedRequests
    });

  } catch (error) {
    console.error('Get lab requests error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Lab Results (Healthcare Provider)
app.get('/api/healthcare/lab-results', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'healthcare') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: labResults, error: labResultsError } = await supabase
      .from('labResult')
      .select(`
        *,
        labRequest!inner(
          request_id,
          test_type,
          staff_id,
          visit!inner(
            visit_id,
            visit_date,
            outPatient!inner(
              patient_id,
              name,
              age,
              sex,
              contact_no
            )
          )
        )
      `)
      .eq('labRequest.staff_id', req.user.id)
      .order('upload_date', { ascending: false });

    if (labResultsError) {
      console.error('Lab results fetch error:', labResultsError);
      return res.status(500).json({ error: 'Failed to fetch lab results' });
    }

    const formattedResults = (labResults || []).map(result => ({
      result_id: result.result_id,
      request_id: result.request_id,
      file_name: result.file_path ? result.file_path.split('/').pop() : 'Unknown File',
      file_url: result.file_path,
      upload_date: result.upload_date,
      results: result.results,
      interpretation: result.interpretation,
      test_type: result.labRequest.test_type,
      patient: {
        patient_id: result.labRequest.visit.outPatient.patient_id,
        name: result.labRequest.visit.outPatient.name,
        age: result.labRequest.visit.outPatient.age,
        sex: result.labRequest.visit.outPatient.sex,
        contact_no: result.labRequest.visit.outPatient.contact_no
      },
      visit_date: result.labRequest.visit.visit_date
    }));

    res.status(200).json({
      success: true,
      labResults: formattedResults
    });

  } catch (error) {
    console.error('Get lab results error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get Lab Requests (Patient Side)
app.get('/api/patient/lab-requests/:patientId', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'outpatient') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patientId } = req.params;

    if (req.user.patientId !== patientId) {
      return res.status(403).json({ error: 'Access denied to other patient data' });
    }

    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id, patient_id, name')
      .eq('patient_id', patientId)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: visits } = await supabase
      .from('visit')
      .select('visit_id')
      .eq('patient_id', patientData.id);

    if (!visits || visits.length === 0) {
      return res.status(200).json({
        success: true,
        labRequests: []
      });
    }

    const visitIds = visits.map(v => v.visit_id);

    const { data: labRequests, error: labRequestsError } = await supabase
      .from('labRequest')
      .select(`
        *,
        visit!inner(visit_id, visit_date),
        healthStaff!staff_id!inner(name, specialization)
      `)
      .in('visit_id', visitIds)
      .order('request_id', { ascending: false });

    if (labRequestsError) {
      console.error('Patient lab requests fetch error:', labRequestsError);
      return res.status(500).json({ error: 'Failed to fetch lab requests' });
    }

    const labRequestIds = labRequests.map(req => req.request_id);
    let labResults = [];
    
    if (labRequestIds.length > 0) {
      const { data: resultsData } = await supabase
        .from('labResult')
        .select('*')
        .eq('patient_id', patientData.id)
        .in('request_id', labRequestIds);
      
      labResults = resultsData || [];
    }

    const formattedRequests = labRequests.map(request => {
      const labResult = labResults.find(result => result.request_id === request.request_id);
      
      return {
        request_id: request.request_id,
        test_name: request.test_type,
        test_type: request.test_type,
        priority: 'normal',
        status: request.status,
        instructions: '',
        due_date: request.due_date,
        created_at: request.visit.visit_date,
        doctor: {
          name: request.healthStaff.name,
          department: request.healthStaff.specialization
        },
        labResult: labResult ? {
          result_id: labResult.result_id,
          file_name: labResult.file_path ? labResult.file_path.split('/').pop() : 'Uploaded File',
          file_url: labResult.file_path,
          upload_date: labResult.upload_date,
          results: labResult.results
        } : null
      };
    });

    res.status(200).json({
      success: true,
      labRequests: formattedRequests
    });

  } catch (error) {
    console.error('Get patient lab requests error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      details: error.message 
    });
  }
});

// Upload Lab Result (Patient)
app.post('/api/patient/upload-lab-result', authenticateToken, upload.single('labResultFile'), async (req, res) => {
  try {
    if (req.user.type !== 'outpatient') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { labRequestId, patientId } = req.body;
    const file = req.file;

    if (!file || !labRequestId || !patientId) {
      return res.status(400).json({ error: 'File, lab request ID and patient ID are required' });
    }

    if (req.user.patientId !== patientId) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id, patient_id')
      .eq('patient_id', patientId)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: labRequestData } = await supabase
      .from('labRequest')
      .select('request_id, visit_id, status')
      .eq('request_id', labRequestId)
      .single();

    if (!labRequestData) {
      return res.status(404).json({ error: 'Lab request not found' });
    }

    const filePath = `/uploads/lab-results/${file.filename}`;

    const { data: labResultData, error: labResultError } = await supabase
      .from('labResult')
      .insert({
        request_id: parseInt(labRequestId),
        patient_id: patientData.id,
        file_path: filePath,
        upload_date: new Date().toISOString().split('T')[0],
        results: JSON.stringify({
          originalName: file.originalname,
          size: file.size,
          mimeType: file.mimetype
        })
      })
      .select()
      .single();

    if (labResultError) {
      console.error('Lab result save error:', labResultError);
      return res.status(500).json({ error: 'Failed to save lab result' });
    }

    await supabase
      .from('labRequest')
      .update({ status: 'completed' })
      .eq('request_id', labRequestId);

    const { data: existingMedicalRecord } = await supabase
      .from('medicalRecord')
      .select('record_id')
      .eq('patient_id', patientData.id)
      .eq('visit_id', labRequestData.visit_id)
      .single();

    if (existingMedicalRecord) {
      await supabase
        .from('medicalRecord')
        .update({ 
          result_id: labResultData.result_id,
          updated_at: new Date().toISOString()
        })
        .eq('record_id', existingMedicalRecord.record_id);
    } else {
      await supabase
        .from('medicalRecord')
        .insert({
          patient_id: patientData.id,
          visit_id: labRequestData.visit_id,
          result_id: labResultData.result_id
        });
    }

    res.status(201).json({
      success: true,
      labResult: {
        result_id: labResultData.result_id,
        file_name: file.originalname,
        file_url: filePath,
        upload_date: labResultData.upload_date
      },
      message: 'Lab result uploaded and medical record updated successfully'
    });

  } catch (error) {
    console.error('Upload lab result error:', error);
    res.status(500).json({ error: 'Internal server error during file upload' });
  }
});

// Patient Visit History
app.get('/api/patient/history/:patientId', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'outpatient') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { patientId } = req.params;

    const { data: patientData } = await supabase
      .from('outPatient')
      .select('id')
      .eq('patient_id', patientId)
      .single();

    if (!patientData) {
      return res.status(404).json({ error: 'Patient not found' });
    }

    const { data: visitHistory, error: visitError } = await supabase
      .from('visit')
      .select(`
        visit_id,
        visit_date,
        visit_time,
        appointment_type,
        symptoms,
        diagnosis(
          diagnosis_description,
          severity
        ),
        queue(
          queue_no,
          status,
          department(name)
        )
      `)
      .eq('patient_id', patientData.id)
      .order('visit_date', { ascending: false });

    res.status(200).json({
      success: true,
      visitHistory: visitHistory || []
    });

  } catch (error) {
    console.error('Patient history error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Generate QR Code and Send Email
app.post('/api/generate-qr-email', async (req, res) => {
  try {
    console.log('QR generation request received');
    
    const { qrData, patientEmail, patientName } = req.body;

    if (!qrData || !patientEmail || !patientName) {
      console.error('Missing required data:', { qrData: !!qrData, patientEmail: !!patientEmail, patientName: !!patientName });
      return res.status(400).json({
        error: 'Missing required data for QR generation'
      });
    }

    console.log('Step 1: Generating QR code...');
    let qrCodeDataURL;
    try {
      const qrString = JSON.stringify(qrData);
      console.log('QR data string length:', qrString.length);
      
      qrCodeDataURL = await QRCode.toDataURL(qrString, {
        width: 256,
        margin: 1,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        }
      });

      console.log('QR code generated successfully');

    } catch (qrError) {
      console.error('QR generation failed:', qrError.message);
      return res.status(500).json({
        error: 'QR code generation failed',
        details: qrError.message
      });
    }

    console.log('Step 2: Converting to buffer...');
    let qrCodeBuffer;
    
    try {
      const base64Data = qrCodeDataURL.replace(/^data:image\/png;base64,/, '');
      qrCodeBuffer = Buffer.from(base64Data, 'base64');
      console.log('Buffer created, size:', qrCodeBuffer.length, 'bytes');
    } catch (bufferError) {
      console.error('Buffer conversion failed:', bufferError.message);
      return res.status(500).json({
        error: 'Image processing failed',
        details: bufferError.message
      });
    }

    console.log('Step 3: Preparing email...');
    const emailHtml = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #f5f5f5; padding: 20px;">
        <div style="background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
          <div style="background: linear-gradient(135deg, #4285f4 0%, #1a73e8 100%); color: white; padding: 30px; text-align: center;">
            <h1 style="margin: 0; font-size: 28px;">CliCare Hospital</h1>
            <p style="margin: 10px 0 0 0; font-size: 16px; opacity: 0.9;">Registration Confirmation</p>
          </div>
          
          <div style="padding: 30px;">
            <h2 style="color: #333; margin-top: 0;">Hello ${patientName},</h2>
            <p style="color: #666; line-height: 1.6; font-size: 16px;">Your registration has been completed successfully! Please present the QR code below when you arrive at the hospital.</p>
            
            <div style="background: #f8f9fa; padding: 30px; border-radius: 8px; text-align: center; margin: 25px 0; border: 2px dashed #dee2e6;">
              <img src="cid:qrcode" alt="Registration QR Code" style="max-width: 200px; height: auto; border: 1px solid #ddd; border-radius: 4px;">
              <p style="color: #666; font-size: 14px; margin: 15px 0 0 0; font-weight: 500;">Present this QR code at registration</p>
            </div>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 25px 0;">
              <h3 style="color: #1a73e8; margin-top: 0; font-size: 18px;">Appointment Details</h3>
              <table style="width: 100%; border-collapse: collapse;">
                <tr style="border-bottom: 1px solid #eee;">
                  <td style="padding: 10px 0; color: #666; font-weight: 600;">Department:</td>
                  <td style="padding: 10px 0; color: #333;">${qrData.department || 'General Practice'}</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                  <td style="padding: 10px 0; color: #666; font-weight: 600;">Date:</td>
                  <td style="padding: 10px 0; color: #333;">${qrData.scheduledDate || 'To be confirmed'}</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                  <td style="padding: 10px 0; color: #666; font-weight: 600;">Time:</td>
                  <td style="padding: 10px 0; color: #333;">${qrData.preferredTime || 'To be confirmed'}</td>
                </tr>
                <tr>
                  <td style="padding: 10px 0; color: #666; font-weight: 600;">Temp ID:</td>
                  <td style="padding: 10px 0; color: #333; font-family: monospace;">${qrData.tempPatientId || 'N/A'}</td>
                </tr>
              </table>
            </div>
            
            <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #2196f3;">
              <h4 style="margin-top: 0; color: #1565c0; font-size: 16px;">What to do next:</h4>
              <ol style="color: #666; margin: 10px 0 0 0; padding-left: 20px; line-height: 1.6;">
                <li>Arrive 15 minutes before your scheduled time</li>
                <li>Go directly to the registration desk</li>
                <li>Show this QR code to the staff</li>
                <li>Wait for your queue number to be called</li>
              </ol>
            </div>
            
            <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
              <p style="color: #999; font-size: 12px; margin: 0;">
                This is an automated message from CliCare Hospital<br>
                Please do not reply to this email
              </p>
            </div>
          </div>
        </div>
      </div>
    `;

    console.log('Step 4: Sending email to:', patientEmail);
    try {
      const transporter = nodemailer.createTransporter({
        service: 'gmail',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASSWORD
        }
      });
      
      await transporter.verify();
      console.log('Email transport verified');
      
      const mailOptions = {
        from: `"CliCare Hospital" <${process.env.EMAIL_USER}>`,
        to: patientEmail,
        subject: `Your CliCare Registration QR Code - ${patientName}`,
        html: emailHtml,
        attachments: [
          {
            filename: 'qr-code.png',
            content: qrCodeBuffer,
            cid: 'qrcode'
          }
        ]
      };

      const result = await transporter.sendMail(mailOptions);
      console.log('Email sent successfully. Message ID:', result.messageId);

    } catch (emailError) {
      console.error('Email sending failed:', emailError.message);
      return res.status(500).json({
        error: 'Failed to send email',
        details: emailError.message
      });
    }

    try {
      await supabase
        .from('tempReg')
        .update({ 
          qr_code: JSON.stringify(qrData),
          updated_at: new Date().toISOString()
        })
        .eq('temp_patient_id', qrData.tempPatientId);
      console.log('Database updated');
    } catch (dbError) {
      console.warn('Database update failed (non-critical):', dbError.message);
    }

    console.log('QR generation and email process completed successfully');

    res.json({
      success: true,
      message: 'QR code generated and sent successfully to ' + patientEmail,
      qrCodeDataURL: qrCodeDataURL
    });

  } catch (error) {
    console.error('Unexpected error in QR generation:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Health Check
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    message: 'CliCare Admin Backend is running',
    timestamp: new Date().toISOString(),
    env: {
      emailConfigured: !!process.env.EMAIL_USER,
      smsConfigured: isSMSConfigured,
      supabaseConfigured: !!SUPABASE_URL,
      smsProvider: 'iTexMo'
    }
  });
});

// Test Email Endpoint
app.post('/api/test-email', async (req,
res) => {
  try {
    const transporter = nodemailer.createTransporter({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD
      }
    });
    
    await transporter.verify();
    
    const result = await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: process.env.EMAIL_USER,
      subject: 'CliCare Email Test',
      text: 'Email configuration is working!'
    });
    
    res.json({ success: true, messageId: result.messageId });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.use((error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'File too large' });
    }
  }
  
  console.error('Unhandled error:', error);
  res.status(500).json({ 
    error: 'Internal server error',
    details: error.message 
  });
});

app.listen(PORT, () => {
  console.log(`CliCare Backend Server running on port ${PORT}`);
  console.log(`Email OTP: ${emailConfig.auth.user ? 'Configured' : 'Not configured'}`);
  console.log(`SMS OTP: ${isSMSConfigured ? 'iTexMo configured' : 'Not configured'}`);
  console.log(`Database: ${SUPABASE_URL ? 'Connected' : 'Not connected'}`);
});

module.exports = app;
